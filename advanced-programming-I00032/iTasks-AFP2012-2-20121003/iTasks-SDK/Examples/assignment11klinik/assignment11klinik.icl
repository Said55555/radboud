module assignment11klinik

import StdMisc
import confSM
import iTask_semantics
import derived_combinators

:: UserEvent
  = UserEditEvent String Int
  | UserActionEvent Action

// Turns a UserEvent into an iTask Event.
//
// UserEvents are generated by the testing framework (by properEvents to be
// precise). A UserEvent addresses a receipient task by the task's label, while
// iTask Events address the task by an internal number.  toRealEvent translates
// between those two by querying the connection between task IDs and labels
// using the Refresh event.
toRealEvent :: UserEvent (Task` a, State) -> Maybe Event`
toRealEvent (UserEditEvent label value) (task, state) =
  case [taskId \\ (taskId, EditorResponse er) <- responses
                | er.EditorResponse.description == label] of
    [] = Nothing
    [taskId:_] = Just (EditEvent` taskId (serialize` value))
where
  (_, responses, _) = task RefreshEvent` state
toRealEvent (UserActionEvent action) (task, state) =
  case [taskId \\ (taskId, ActionResponse` actions) <- responses
                | isMember action (map fst actions)] of
    [] = Nothing
    [taskId:_] = Just (ActionEvent` taskId action)
where
  (_, responses, _) = task RefreshEvent` state

// Extracts the task ID from an Event
eventTaskId :: Event` -> TaskNo
eventTaskId (EditEvent`   taskId _) = taskId
eventTaskId (ActionEvent` taskId _) = taskId

// This is the response we give when the input event is addressed to a task
// which doesn't exist.
errorResponse = EditorResponse { EditorResponse
                               | description = "no transition for input"
                               , editValue = (serialize` False, serialize` False)
                               , editing = Displaying
                               }

// Common code for specTask and iutTask.
//
// specTask and iutTask are essentially the same, only the type of the result
// is a bit different. We pass a function for that.
stepTask :: (Task` a, State) UserEvent ([Response] (Task` a, State) -> b) -> b
stepTask (task, state) input mkResult =
  case (toRealEvent input (task, state)) of
    // The task does not have an editor of action to whom the input event may be sent
    Nothing = mkResult [errorResponse] (task, state)
    (Just realInput)
      # ((Reduct (ValRes` _ _) newTask), responses, newState) = task realInput state
      // return only the responses from the task where we sent the input to
      = mkResult [response \\ (senderTaskId, response) <- responses
                            | senderTaskId == eventTaskId realInput]
                 (newTask, newState)

specTask :: (Task` a, State) UserEvent -> [Trans Response (Task` a, State)]
specTask state input = stepTask state input (\responses newState -> [Pt responses newState])

iutTask :: (Task` a, State) -> UserEvent -> ([Response], (Task` a, State))
iutTask state = \input -> stepTask state input (\responses newState -> (responses, newState))

// The initial state for testing.  We use it for both the specification and the
// implementation.
initState = { State | mem = [], taskNo = 0, timeStamp = 0 }

// Yields the list of all events that would make sense in the given task/state
// combination.
//
// I always wondered what list comprehensions are good for when you have map,
// fold and filter.  Thank's for teaching me, Peter!
properEvents :: (Task` a, State) -> [UserEvent]
properEvents (task, state) =
  // Proper events are: edit events for all available editors (we only toggle
  // between a few values), ...
  [  UserEditEvent er.EditorResponse.description value
  \\ (_, EditorResponse er) <- responses
  ,  value <- [0, 1, 42]
  ]
  ++
  // ... and action events for all available actions.
  [  UserActionEvent action
  \\ (_, ActionResponse` actionResponses) <- responses
  ,  (action, enabled) <- actionResponses
  |  enabled
  ]
where
  (_, responses, _) = task RefreshEvent` state


// This function was given in the assignment text.
taskConformance :: *World (Task` a) (Task` a) -> *World  | gEq {| * |} a & genShow {| * |} a
taskConformance world task1 task2
  = snd (testConfSM options
                    specTask
                    (task1, initState)
                    iutTask
                    (task2, initState)
                    (const (task2, initState))
                    world
        )
  where
    options =
      [ InputFun (const properEvents)
      , Ntests 100
      , Nsequences 10
      ]

derive ggen UserEvent, Action
derive bimap []
derive genShow Event`, State, Reduct, Response, UserEvent, Action,
  TaskResult`, EditorResponse, Value`, EditMode, Stability`

genShow{|SerializedValue|} _ _ _ c = c

// The various tests.  testConfSM, and hence taskConformance, cannot be used as
// a single unit test, and therefore cannot be chained in one run.  Or am I
// missing something?  testConfSM doesn't return a value that indicates the
// test outcome.

Start world = taskConformance world task5 task6 // should pass, passes
//Start world = taskConformance world task1 task2 // should pass, passes
//Start world = taskConformance world task2 task1 // should fail, fails
//Start world = taskConformance world task3 task4 // should pass, passes
//Start world = taskConformance world task4 task3 // should pass, passes
//Start world = taskConformance world task5 task6 // should pass, passes
//Start world = taskConformance world task6 task5 // should pass, passes
//Start world = taskConformance world taskX taskY // should fail, fails
//Start world = taskConformance world (return` 0) (task1 .||. return` 0) // should pass, passes
//Start world = taskConformance world (return` 0) (return` 0 .||. task1) // should pass, passes
//Start world = taskConformance world (return` 0 .||. task1) (return` 0) // should fail, fails

task1 = (simplified_edit "edit1" 42)
task2 = (simplified_edit "edit1" 42) >>>* [OnAction` (Action "Ok") (isValue) (return` o getValue)]

taskX = (simplified_edit "edit1" 42)
taskY = (simplified_edit "edit2" 42) >>>* [OnAction` (Action "Ok") (isValue) (return` o getValue)]

task3 = (taskX .||. taskY)
task4 = (taskY .||. taskX)

task5 = (simplified_edit "edit1" 42    .||. simplified_edit "edit2" (-42))
task6 = (simplified_edit "edit2" (-42) .||. simplified_edit "edit1" 42)
