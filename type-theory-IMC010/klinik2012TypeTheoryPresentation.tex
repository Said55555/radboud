\documentclass{beamer}

\beamertemplatenavigationsymbolsempty

\mode<presentation>
{
  \usetheme{default}
}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{bussproofs}

% needs debian package texlive-math-extra
\usepackage{stmaryrd} % for \llbracket, \rrbracket

% for IEEEeqnarray, needs debian package texlive-publishers
\usepackage[retainorgcmds]{IEEEtrantools}

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.

\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}

\title
{Syntax Directed Type Checking for Pure~Type~Systems}

\author
{Markus~Klinik}

\institute[Radboud University Nijmegen] % (optional, but mostly needed)
{
  Radboud University Nijmegen
}

\date
{Type Theory and Proof Assistants 2012}


\newcommand{\arr}{\rightarrow}
\newcommand{\Arr}{\Rightarrow}

% church-style (explicit) abstraction. We adjust the spacing around the colon and dot
\newcommand{\church}[4]{#1 #2\!:\!#3\,.\,#4}

% something is of type something  x : A, we adjust the spacing
\newcommand{\oftype}[2]{#1\!:\!#2}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Outline}
  \tableofcontents
  % You might wish to add the option [pausesections]
\end{frame}


% Structuring a talk is a difficult task and the following structure
% may not be suitable. Here are some rules that apply for this
% solution:

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

% - A conference audience is likely to know very little of what you
%   are going to talk about. So *simplify*!
% - In a 20min talk, getting the main ideas across is hard
%   enough. Leave out details, even if it means being less precise than
%   you think necessary.
% - If you omit details that are vital to the proof/implementation,
%   just say so once. Everybody will be happy with that.

\section{What?}

\subsection{What is Type Checking?}


\begin{frame}{What is Type Checking?}

  \begin{itemize}
    \item
      Type Checking: Given $\Gamma$, $M$ and $A$, decide whether the judgement
      $\Gamma \vdash M : A$ is derivable
    \item
      Type Synthesis: Given $\Gamma$ and $M$, compute an $A$ such that $\Gamma
      \vdash M : A$
    \item
      We need a type system
      \begin{itemize}
        \item
          Syntax
        \item
          Typing rules
      \end{itemize}
  \end{itemize}

\end{frame}


\subsection{What Does ``Syntax Directed'' Mean?}


\begin{frame}{What Does ``Syntax Directed'' Mean?}

  \begin{center}
  $M ::= x\ |\ M M\ |\ \lambda x . M$
  \end{center}

  \begin{IEEEeqnarray*}{rCl}
    FV(x)   & = & \{x\} \\
    FV(M N) & = & FV(M) \cup FV(N) \\
    FV(\lambda x . M) & = & FV(M) \textbackslash \{x\}
  \end{IEEEeqnarray*}

\end{frame}

\begin{frame}[fragile]{A Syntax Directed Function}

  \small{\begin{verbatim}
data Term
  = Var Char
  | App Term Term
  | Abs Char Term

freeVars :: Term -> [Char]
freeVars (Var v)   = [v]
freeVars (App l r) = freeVars l `union` freeVars r
freeVars (Abs v t) = filter (/= v) (freeVars t)
  \end{verbatim}}

\end{frame}


\subsection{What are PTSs?}

\begin{frame}{What are PTSs?}

  \begin{itemize}
    \item
      Generalized type systems
    \item
      $\lambda$-zoo $\arr$ $\lambda$-cube $\arr$ PTSs
    \item
      Identical syntax
    \item
      Parametrized typing rules
  \end{itemize}

\end{frame}


\begin{frame}{The Ingredients to Generalized Typing}

  \begin{itemize}
    \item
      One syntactic category for terms and types
    \item
      Introduce \emph{sorts}
    \item
      Introduce \emph{dependent function types}
  \end{itemize}

\end{frame}


\begin{frame}{The $\lambda$-Cube: Syntax}

  \begin{center}
    $M ::= x \ |\ \star \ |\ \square \ |\ MM \ |\ \church{\lambda}{x}{M}{M} \ |\ \church{\Pi}{x}{M}{M}$
  \end{center}

  \begin{center}
    \begin{prooftree}
     \AxiomC{$M:(\church{\Pi}{x}{\sigma}{\tau(x)})$}
     \AxiomC{$N:\sigma$}
     %\RightLabel{[Unit]}
     \BinaryInfC{$MN:\tau(N)$}
    \end{prooftree}
  \end{center}

\end{frame}

\newcommand{\ruleAxiom}{
  \begin{prooftree}
     \AxiomC{}
     \LeftLabel{(axiom)}
     \UnaryInfC{$\vdash \star : \square$}
  \end{prooftree}
}

\newcommand{\ruleStart}{
  \begin{prooftree}
     \AxiomC{$\Gamma \vdash A : s$}
     \LeftLabel{(start)}
     \UnaryInfC{$\Gamma , \oftype{x}{A} \vdash \oftype{x}{A}$}
  \end{prooftree}
}

\newcommand{\ruleWeakening}{
  \begin{prooftree}
    \AxiomC{$\Gamma \vdash \oftype{M}{B}$}
    \AxiomC{$\Gamma \vdash \oftype{A}{s}$}
    \LeftLabel{(weakening)}
    \BinaryInfC{$\Gamma , \oftype{x}{A} \vdash \oftype{M}{B}$}
  \end{prooftree}
}

\newcommand{\ruleApplication}{
  \begin{prooftree}
    \AxiomC{$\Gamma \vdash \oftype{M}{(\church{\Pi}{x}{A}{B})}$}
    \AxiomC{$\Gamma \vdash \oftype{N}{A}$}
    \LeftLabel{(application)}
    \BinaryInfC{$\Gamma \vdash \oftype{MN}{[N/x]B}$}
  \end{prooftree}
}

\newcommand{\ruleAbstraction}{
  \begin{prooftree}
    \AxiomC{$\Gamma , \oftype{x}{A} \vdash \oftype{M}{B}$}
    \AxiomC{$\Gamma \vdash \oftype{(\church{\Pi}{x}{A}{B})}{s}$}
    \LeftLabel{(abstraction)}
    \BinaryInfC{$\Gamma \vdash \oftype{(\church{\lambda}{x}{A}{M})}
                                      {(\church{\Pi}{x}{A}{B})}$}
  \end{prooftree}
}

\newcommand{\ruleConversion}{
  \begin{prooftree}
    \AxiomC{$\Gamma \vdash \oftype{M}{A}$}
    \AxiomC{$A =_{\beta} B$}
    \AxiomC{$\Gamma \vdash \oftype{B}{s}$}
    \LeftLabel{(conversion)}
    \TrinaryInfC{$\Gamma \vdash \oftype{M}{B}$}
  \end{prooftree}
}

\newcommand{\ruleProduct}{
  \begin{prooftree}
    \AxiomC{$\Gamma \vdash \oftype{A}{s_1}$}
    \AxiomC{$\Gamma , \oftype{x}{A} \vdash \oftype{B}{s_2}$}
    \LeftLabel{(product)}
    \BinaryInfC{$\Gamma \vdash \oftype{(\church{\Pi}{x}{A}{B})}{s_2}$}
  \end{prooftree}
}

\begin{frame}{$\lambda$-Cube Typing Rules}

  \begin{columns}

    \begin{column}{0.5\textwidth}
      \ruleAxiom
    \end{column}

    \begin{column}{0.5\textwidth}
      \ruleStart
    \end{column}

  \end{columns}

  \ruleWeakening

  \ruleApplication

  \ruleAbstraction

  \ruleProduct

  \ruleConversion

\end{frame}

\begin{frame}{$\lambda$-Cube Rules: Axiom, Start}

  \begin{prooftree}
     \AxiomC{}
     \LeftLabel{(axiom)}
     \UnaryInfC{$\vdash \star : \square$}
  \end{prooftree}

  \begin{prooftree}
     \AxiomC{$\Gamma \vdash A : s$}
     \LeftLabel{(start)}
     \UnaryInfC{$\Gamma , \oftype{x}{A} \vdash \oftype{x}{A}$}
  \end{prooftree}

\end{frame}


\section{Syntax Directed Type Checking for PTSs}

\subsection{The Problem}

\begin{frame}{The Problem}

  \begin{itemize}
    \item
      Foo
    \item
      Bar
    \item
      Baz
  \end{itemize}

\end{frame}


\subsection{Step 1: The Weakening Rule}

\begin{frame}{The Weakening Rule}

  \begin{itemize}
    \item
      Foo
    \item
      Bar
    \item
      Baz
  \end{itemize}

\end{frame}


\subsection{Step 2: Maintaining Context Validity}

\begin{frame}{Maintaining Context Validity}

  \begin{itemize}
    \item
      Foo
    \item
      Bar
    \item
      Baz
  \end{itemize}

\end{frame}


\subsection{Step 3: The Conversion Rule}

\begin{frame}{The Conversion Rule}

  \begin{itemize}
    \item
      Foo
    \item
      Bar
    \item
      Baz
  \end{itemize}

\end{frame}


%\subsection{Step 4: The Abstraction Rule}

%\begin{frame}{The Abstraction Rule}

  %\begin{itemize}
    %\item
      %Foo
    %\item
      %Bar
    %\item
      %Baz
  %\end{itemize}

%\end{frame}


%\subsection{Step 5: Regain Completeness}

%\begin{frame}{Regain Completeness}

  %\begin{itemize}
    %\item
      %Foo
    %\item
      %Bar
    %\item
      %Baz
  %\end{itemize}

%\end{frame}


\section*{Summary}

\begin{frame}{Summary}

  \begin{itemize}
  \item
    Conclusion A
  \item
    Conclusion B
  \item
    Conclusion C
  \end{itemize}

\end{frame}


\end{document}


