\documentclass[a4paper]{article}

%\usepackage{mathptmx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}
%\usepackage[square]{natbib}

% needs debian package texlive-math-extra
\usepackage{stmaryrd} % for \llbracket, \rrbracket (scott brackets)

\usepackage{bussproofs}
\def\defaultHypSeparation{\hskip .1in}

\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{matrix}

\newcommand{\arr}{\rightarrow}
\newcommand{\todo}[1]{\bigskip \noindent \emph{todo: #1}}
%\newcommand{\todo}[1]{}
\newcommand{\semantics}[1]{\llbracket #1 \rrbracket}

% church-style (explicit) abstraction. We adjust the spacing around the colon and dot
\newcommand{\church}[4]{#1 #2\!:\!#3\,.\,#4}

\newcommand{\curry}[3]{#1 #2\,.\,#3}

% something is of type something  x : A, we adjust the spacing
\newcommand{\oftype}[2]{#1\!:\!#2}

\begin{document}

\title{A Typechecker for SPL, the Simple~Programming~Language}
\author{Markus Klinik (s4220315)}
\maketitle

\begin{abstract}

This report describes design decisions and typing rules for the
implementation of the type checker for the course NWI-IMC004 Compiler
Construction.

\end{abstract}

\section{Implementation language}

The SPL parser and type checker are written in Haskell, because a
functional language is well-suited for the various programming tasks
that arise when implementing a compiler.

\begin{itemize}

  \item Traversing trees by pattern matching and recursion on algebraic
  data types is most convenient.

  \item Immutable data structures and sharing allow a style of
  programming that resembles mathematical definitions.  This comes in
  handy for example when an environment needs to be passed modified to
  a subcomputation, but the original environment is needed again later.

  \item Haskell has a rich set of standard and third-party libraries
  which allows focusing on the problem at hand.

\end{itemize}

\section{Grammar}

The Parser is implemented in a top-down style using the uu-parsinglib
parser combinator library.  The grammar is kept mostly unmodified,
making use of the backtracking features of uu-parsinglib.  Focus was
put more on conciseness of the implementation rather than run-time
performance.

There are three important changes to the grammar.  The first one is the
introduction of intermediate non-terminals to account for the different
precedence levels of binary operators.  These intermediate
non-terminals are not given names, they arise by mapping parser
constructing functions over a suitably nested list of strings, followed
by folding the result with left- and right chaining combinators,
according to their associativity.

The second change to the grammar is one left-factorization in the rule
for expressions, to get rid of backtracking when an expression in the
input starts with many opening parenthesis.

The third grammar change is due to scoping issues, and described in the next
section.

\section{Scoping rules}

Before getting to scoping rules, we need to discuss the role of type
annotations, and mutual recursion.

\subsection{Type annotations}

There are two different ways to interpret type
annotations \cite{Pierce2002a}.  Consider the following two lambda-terms, one
in Curry-style without type annotations and the other one in
Church-style with type annotations.

\begin{IEEEeqnarray}{c}
\label{curryterm}\curry{\lambda}{f}{\curry{\lambda}{x}{f(f x)}}\\
\label{churchterm}\church{\lambda}{f}{a}{\church{\lambda}{x}{b}{f(f x)}}
\end{IEEEeqnarray}

When type checking term (\ref{curryterm}) in a polymorphic type system,
the type inference algorithm would infer that the term has type
$(a \arr a) \arr a \arr a$, and conclude that the term is
well typed.  For term (\ref{churchterm}), considered under the same
typing rules, the question arises what the meaning of the type
variables $a$ and $b$ is.  These two are possible:

\begin{enumerate}

 \item \label{interp_exists} There exists a substitution ${}^*$ for
 $a$, $b$, $c$ such that term (\ref{churchterm}) has type $(a \arr b
 \arr c)^*$.

 \item \label{interp_forall} For all substitutions ${}^{*_1}$ of $a$
 and $b$, there exists a substitution ${}^{*_2}$ of $c$ such that term
 (\ref{churchterm}) has type $(a^{*_1} \arr b^{*_1} \arr c^{*_2})$.

\end{enumerate}

Under the first interpretation, term (\ref{churchterm}) would
be well-typed, because clearly such a substitution exists.  Take $[a
\arr (\text{Int} \arr \text{Int}), b \arr \text{Int}, c \arr
\text{Int}]$.

Under the second interpretation, term (\ref{churchterm}) would not be
well-typed, because for the substitution $[a \arr \text{Int}, b \arr
\text{Int}]$, there is no substitution ${}^*$ for $c$ such that the term has
type $(\text{Int} \arr \text{Int} \arr c^*)$.

A similar term that would be well-typed under both the first and the second
interpretation is the following one:

\begin{IEEEeqnarray*}{c}
\church{\lambda}{f}{a \arr a}{\church{\lambda}{x}{a}{f(f x)}}
\end{IEEEeqnarray*}

The grammar for SPL, as given in the first exercise, does not allow type
annotations of function types.  We therefore have to either choose the first
interpretation, or add function types to the grammar to choose the second
interpretation.  The first interpretation seemed more challenging, so the
present implementation of the SPL compiler chooses this one.

\subsection{Polymorphism and mutual recursion}

When inferring the type of a set of mutually recursive functions, all
constraints that arise in the bodies of the functions have to be unified
simultaneously.  Otherwise, the types of the functions become too general.
Consider the following mutually recursive functions $f$ and $g$.

\begin{verbatim}
a f(b x, c y) { return g(y, x); }
a g(b x, c y) { return f(x, y); }
\end{verbatim}

The type of both of them must be $\forall a b . (a \arr a \arr b)$, but if the
type inference algorithm would introduce $f$ all-quantified into the context
before calculating the constraints of $g$, it would infer the type $\forall a b
c .  (a \arr b \arr c)$ for both $f$ and $g$.

On the other hand, the constraints of functions which are not mutually recursive
must never be unified simultaneously, because otherwise they could get types
which are not general enough.  Consider the following example.

\begin{verbatim}
a id(a x) { return x; }
Void h() { id(10); return; }
\end{verbatim}

If the type inference algorithm would unify the types of \emph{h} and \emph{id}
simultaneously, it would infer the type $(\text{Int} \arr \text{Int})$ for
\emph{id}.  This means that the type inference algorithm must first infer the
type of \emph{id} separately, introduce it all-quantified as $\forall a . (a
\arr a)$ to the context, and then infer the type of \emph{h}.

It therefore seems that no matter which of the above we choose, the following
program would give either a type error for \emph{id} or too general types to
\emph{f} and \emph{g}.

\begin{verbatim}
a id(a x) { return x; }
a f(b x, c y) { id(10); return g(y, x); }
a g(b x, c y) { id(True); return f(x, y); }
\end{verbatim}

It appears that we must choose one of the following alternatives.

\begin{itemize}
  
  \item Forbid mutual recursion.

  \item Require forward declarations, like in C.

  \item Let the programmer explicitly specify the functions whose types should
  be unified simultaneously.

  \item Make the type checker analyse dependencies of function definitions to
  find cycles and thus automatically determine which functions to unify
  simultaneously.

\end{itemize}

The first alternative would result in a much easier implementation of the type
checker, at the cost of flexibility for the programmer.

The second alternative would run counter to the idea of type inference.

The third alternative, realizable for example by explicit let-bindings which
allow several bindings to be defined at once, places the burden of resolving
dependencies on the programmer.

Clearly, the fourth alternative would be preferable, and it should indeed be
possible to automatically determine dependencies between functions by just
looking at the free variables that occur in the function bodies.

The implementation at hand chooses the third alternative, as a tradeoff between
flexibility and ease of implementation.

\subsection{Polymorphism and assignments}

Another issue is polymorphic type inference in presence of assignments.  The
question is whether to all-quantify free type variables in local and global
variables.  To illustrate the problem, consider the following program.

\begin{verbatim}
fun f() {
  var x = [];
  x = 1:[];
  x = True:[];
}
\end{verbatim}

If the type checker would introduce $x$ all-quantified to the environment when
type checking the function body, $x$ would be of type $\forall a . [a]$, which
could be specialized to $[\text{Int}]$ in the first assignment, and to
$[\text{Bool}]$ in the second.  Clearly, this is unsound.  Pierce, in his
chapter about mutable references \cite{Pierce2002a}, solves this problem by
all-quantifying the type of an identifier only if its initializer is a
syntactic value.  He argues that this restriction has no big impact on
usability.  In his language, reference cell constructors are not values, so
identifiers initialized with a reference cell are never all-quantified.  In
SPL, as variables are always mutable, every variable is always implicitly a
reference cell, so by adopting the \emph{value restriction} in the type checker
at hand, the types of variables are never all-quantified.  This gives the
desired type error for the program above. Unfortunately this comes at the
tradeoff that programs like the following, in which an identifier is never
assigned to, also give type errors. This is because the type of $x$ gets
constrained to both $[\text{Int}]$ and $[\text{Bool}]$.

\begin{verbatim}
fun f() {
  var x = [];
  return (1:x, True:x);
}
\end{verbatim}

In the current implementation of the type checker for SPL, we adopt this
restriction, and accept the tradeoff.

Special care must be taken for function arguments involved in assignments.
Consider the following program.

\begin{verbatim}
var x = [];
fun f(y y, z z) {
  x = y;
  return z;
}
Void main() {
  f(True:[], True);
  f(10:[], 10);
  return;
}
\end{verbatim}

To be sound, we must preclude the type of $y$ to be generalized when $f$ is
introduced to the environment.  Otherwise, it would be possible to use the
all-quantification of $f$ to assign values of different types to the global $x$.
Fortunately, this is easy.  By adopting the value restriction, the type of $x$
is not all-quantified, which means it's type has a free variable.  It gets type,
say, $[z]$, where $z$ is fresh.  The algorithm then generalizes the free
variables of functions only if they are not free in the environment.  In the
example above, the type of $y$ is constrained to the type of $x$, which has a
free type variable, so the type of $f$ would be $\forall a . ([z] \arr a \arr
a)$, where z is the same fresh type variable used for the type of $x$.  This
way, the type of the first argument of $f$ and the type of $x$ are constrained
together, which will give a type error in one of the two calls of $f$ in
\emph{main}.

The scoping rules implied by the design
decisions discussed so far are described in the following section.

\subsection{Scoping rules}

First, we change the production rule for SPL programs as follows:

\begin{IEEEeqnarray*}{rCl}
\text{Prog} & ::= & \text{Decl}\!+\\
\text{Decl} & ::= & \text{SingleDecl}\ |\ \text{FunDeclBlock}\\
\text{SingleDecl} & ::= & \text{VarDecl}\ |\ \text{FunDecl}\\
\text{FunDeclBlock} & ::= & `\{`\ \text{FunDecl}\!+ `\}`
\end{IEEEeqnarray*}

An SPL program is therefore a list of declarations, where a declaration is
either a single variable or function declaration, or a block of function
declarations.

The scoping rules for global identifiers are then as follows.

\begin{itemize}

  \item All identifiers within a block of declarations are visible
  simultaneously to each other.

  \item Identifiers defined earlier are visible later, but not vice versa.

  \item When a name collision occurs, the earlier declaration is silently
  shadowed.  There are no error or warning messages yet.

\end{itemize}

For local identifiers, there is only one scoping rule.

\begin{itemize}

  \item All local identifiers defined in a function body are visible
  simultaneously, inside the whole function body.

\end{itemize}

This way, the problematic example with mutual recursion from above can be
correctly typed, when given as follows.

\begin{verbatim}
a id(a x) { return x; }
{
a f(b x, c y) { id(10); return g(y, x); }
a g(b x, c y) { id(True); return f(x, y); }
}
\end{verbatim}

The function \emph{id}, gets type $\forall a .  (a \arr a)$, and $f$ and $g$
both get type $\forall a b . (a \arr a \arr b)$.


\section{Typing rules}

The typing relation is a 4-place relation of an environment $\Gamma$, a
syntactic construct, a type and a substitution.  We read a typing judgement
$\Gamma \vdash \oftype{e}{\sigma} | *$ as ``In the environment $\Gamma$, the
syntactic construct $e$ has type $\sigma$, under the substitution $*$''.  The
premises of the typing rules are to be read from left to right.

The typing relation is defined by recursion on the abstract syntax as follows.
The label to the left is the name of the rule, while the label to the right
describes side conditions.

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, \text{Bool})$}
\LeftLabel{(Bool)}
\RightLabel{$b \in \{\text{True}, \text{False}\}$}
\UnaryInfC{$\Gamma \vdash \oftype{b}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, \text{Int})$}
\LeftLabel{(Int)}
\RightLabel{$i \in \mathbb{Z}$}
\UnaryInfC{$\Gamma \vdash \oftype{i}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, a)$}
\LeftLabel{(empty list)}
\RightLabel{$a$ fresh}
\UnaryInfC{$\vdash \oftype{[]}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e_1}{a_1} | *_1$}
\AxiomC{$\Gamma^{*_1} \vdash \oftype{e_2}{a_2} | *_2$}
\AxiomC{$*_3 = \mathcal{U}(\sigma^{*_2 \circ *_1}, (a_1, a_2)^{*_2 \circ *_1})$}
\LeftLabel{(tuple)}
\RightLabel{$a_1$, $a_2$ fresh}
\TrinaryInfC{$\Gamma \vdash \oftype{(e_1, e_2)}{\sigma} | *_3 \circ *_2 \circ *_1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\tau = \Gamma(i)$}
\AxiomC{$* = \mathcal{U}(\sigma, \tau)$}
\LeftLabel{(identifier)}
\RightLabel{$i$ identifier}
\BinaryInfC{$\Gamma \vdash \oftype{i}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{\odot(e_1, e_2)}{\sigma} | *$}
\LeftLabel{(binary operator)}
\RightLabel{$\odot$ binary operator}
\UnaryInfC{$\Gamma \vdash \oftype{e_1 \odot e_2}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{\bullet(e)}{\sigma} | *$}
\LeftLabel{(unary operator)}
\RightLabel{$\bullet$ unary operator}
\UnaryInfC{$\Gamma \vdash \oftype{\bullet e}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\tau = \Gamma(f)$}
\AxiomC{$* = \mathcal{U}(\tau, (\vec{\alpha} \arr \sigma))$}
\AxiomC{$\Gamma^*\ \vec{\vdash}\ \oftype{\vec{e}}{(\vec{\alpha})^*} | *_1$}
\LeftLabel{(function call expression)}
\RightLabel{$\vec{\alpha}$ fresh and $|\vec{\alpha}| = |\vec{e}|$}
\TrinaryInfC{$\Gamma \vdash \oftype{f(\vec{e})}{\sigma} | *_1 \circ\,*$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, \text{Void})$}
\LeftLabel{(return Void)}
\UnaryInfC{$\Gamma \vdash \oftype{\text{return}}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e}{\sigma} | *$}
\LeftLabel{(return a value)}
\UnaryInfC{$\Gamma \vdash \oftype{\text{return e}}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma       \vdash \oftype{e}{\text{Bool}} | *_1$}
\AxiomC{$\Gamma^{*_1} \vdash \oftype{s_1}{\sigma^{*_1}} | *_2$}
\AxiomC{$\Gamma^{*_2 \circ *_1} \vdash \oftype{s_2}{\sigma^{*_2 \circ *_1}} | *_3$}
\LeftLabel{(if-then-else)}
\TrinaryInfC{$\Gamma \vdash \oftype{\text{if}(e) s_1 \text{ else } s_2}{\sigma} | *_3 \circ *_2 \circ\,*_1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vec{\vdash}\ \oftype{\vec{s}}{\vec{\sigma}} | *$}
\LeftLabel{(statement block)}
\RightLabel{$\vec{\sigma} = \langle\sigma, \sigma, \ldots, \sigma\rangle$}
\UnaryInfC{$\Gamma \vdash \oftype{\vec{s}}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e}{\text{Bool}} | *_1$}
\AxiomC{$\Gamma^{*_1} \vdash \oftype{s}{\sigma^{*_1}} | *_2$}
\LeftLabel{(while)}
\BinaryInfC{$\Gamma \vdash \oftype{\text{while}(e) s}{\sigma} | *_2 \circ *_1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\tau = \Gamma(i)$}
\AxiomC{$\Gamma \vdash \oftype{e}{\tau} | *$}
\LeftLabel{(assignment)}
\BinaryInfC{$\Gamma \vdash \oftype{i := e}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{f(\vec{e})}{\alpha} | *$}
\LeftLabel{(function call statement)}
\RightLabel{$\alpha$ fresh}
\UnaryInfC{$\Gamma \vdash \oftype{f(\vec{e})}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e}{\sigma} | *$}
\LeftLabel{(variable declaration)}
\UnaryInfC{$\Gamma \vdash \oftype{i = e}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$P_1$}
\AxiomC{$P_2$}
\AxiomC{$P_3$}
\LeftLabel{(function declaration)}
\RightLabel{$\vec{\beta} = \text{derive}(\vec{\alpha}), \beta = \text{derive}(\alpha)$}
\TrinaryInfC{$\Gamma \vdash \oftype{
  \alpha f(\oftype{\vec{i}}{\vec{\alpha}})
  \vec{l} s}{\sigma} | *_3 \circ *_2 \circ\,*_1$}
\end{prooftree}

Where the premises $P_1$ - $P_3$ are:
\begin{IEEEeqnarray*}{rCl}
(P_1) & : & (*_1, \Gamma') = \text{intro}(\vec{l}, (\Gamma, \oftype{\vec{i}}{\vec{\beta}}))\\
(P_2) & : & \Gamma' \vdash \oftype{s}{\beta^{*_1}} | *_2\\
(P_3) & : & *_3 = \mathcal{U}(\sigma^{*_2 \circ *_1}, (\vec{\beta} \arr \beta)^{*_2 \circ *_1})
\end{IEEEeqnarray*}

\begin{prooftree}
\AxiomC{$(\_\,, \Gamma') = \text{intro}(\vec{d}_1)$}
\AxiomC{$\Gamma' \vdash \oftype{\langle \vec{d}_2, \ldots, \vec{d}_n \rangle}{\sigma} | *$}
\LeftLabel{(program)}
\BinaryInfC{$\Gamma \vdash \oftype{\langle \vec{d}_1, \vec{d}_2, \ldots, \vec{d}_n \rangle}{\sigma} | *$}
\end{prooftree}

Looking up the type of an identifier $i$ in an environment $\Gamma$ is defined
as follows.

\begin{equation*}
\Gamma(i) = \text{if } (i, \forall \vec{\alpha}.\tau) \in \Gamma \text{ then } \tau[\vec{\alpha} \mapsto
\vec{\beta}], \text{ where } \vec{\beta} \text{ fresh}
\end{equation*}

That is, we generate a fresh type variable for each bound type variable (if any)
in the type of $i$, then we remove the quantifier and replace all
previously bound variables with the fresh ones.

Inferring the types of a vector of expressions is defined by recursion on the
length of the vector as follows. It is assumed that $|\vec{e}| =
|\vec{\alpha}|$.

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma\ \vec{\vdash}\ \oftype{\langle\rangle}{\langle\rangle} | \text{id}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e_1}{\alpha_1}|*$}
\AxiomC{$\Gamma^*\ \vec{\vdash}\ \oftype{\langle e_2, \ldots, e_n
\rangle}{(\langle \alpha_2, \ldots, \alpha_n\rangle)^*}|*_1$}
\BinaryInfC{$\Gamma\ \vec{\vdash}\ \oftype{\langle e_1, e_2, \ldots,
e_n\rangle}{\langle \alpha_1, \alpha_2, \ldots, \alpha_n\rangle} | *_1 \circ\,*$}
\end{prooftree}

In the rule (function call statement), we use the rule (function call
expression) in the premise, and discard the inferred type.

The function \emph{derive}, used in the rule (function declaration) and by the
function \emph{intro}, generates fresh types, similar to \emph{fresh}, but
\emph{derive} uses the type annotation present in the abstract syntax tree to
generate a fresh type of that shape.  The same variables in the type annotation
become the same fresh type variables.  For example, if $(a \arr b \arr a)$ is a
type annotation, then \emph{derive}$(a \arr b \arr a)$ returns $(c \arr d \arr
c)$, with $c$ and $d$ fresh.

The function \emph{intro}, used in rules (function declaration) and (program),
is the clause of the type inference function that we have seen in the lecture on
slide 13, ``Multiple recursion (2)'', with these differences:

\begin{itemize}

  \item Instead of fresh type variables, it uses \emph{derive}.

  \item Free type variables in types of variables are never quantified.

  \item Instead of recursing into the body of the let binding, \emph{intro}
  returns the calculated modified environment and substitution.

\end{itemize}

In the rule (program), each $\vec{d}_i$ is a list of declarations.  Each of
these lists is type checked simultaneously, then added to the environment.
These two things are done by \emph{intro}.  The rest of the program is type
checked in the modified environment returned by \emph{intro}.

Type checking starts in an initial environment which is pre-loaded with the
definitions for the built in functions and operators.  Both binary and unary
operators are treated as function calls, so their type is looked up in the
environment.

\section{Further work}

There are a few open points in the current implementation.

\begin{itemize}

  \item All identifiers are tracked in the same environment.  Therefore, the
  type checker doesn't forbid assignments to identifiers which refer to
  functions, or even built-in functions.

  \item There are no warnings or errors when name clashes occur.  The previously
  defined identifier is silently shadowed.

  \item Requiring the programmer to explicitly separate blocks of declarations
  could be automated by a dependency analysis.

\end{itemize}


\section{Examples}

\subsection{Examples for p2}

This section contains descriptions for the example programs that accompany this
document.  Each example is given in an .spl file, and the output of the compiler
is given in a .txt file with the same filename.

\begin{description}

  \item[pass-fold-map.spl] Functions usually found in functional programming
  \emph{foldl}, \emph{foldr}, \emph{map} and \emph{filter}.

  \item[pass-mutual-recursion.spl] Two mutually recursive functions. The
  arguments are flipped in the recursive calls, constraining their types to $(a
  \arr a \arr b)$.

  \item[pass-mutual-recursion-lists.spl] Two mutually recursive lists.  The
  third list constrains all three of them to be of type $[\text{Int}]$.

  \item[pass-polymorphism-mutual-recursion.spl] The polymorphic identity can be
  instantiated differently in two mutually recursive functions.  This works only
  because of the scope separator token, which causes $f$ and $g$ to be unified
  independently of \emph{id}.  Removing the scope separator token gives a type
  error.  See fail-polymorphism-mutual-recursion.spl

  \item[fail-polymorphism-mutual-recursion.spl] The polymorphic identity cannot
  be instantiated differently in two mutually recursive functions.  That is
  because the types of all three functions are unified simultaneously.

  \item[pass-transitive-locals-backwards.spl] The return type of the function
  constrains all local variables to be of type $\text{Int}$, which constrains
  the function argument to be also of type $\text{Int}$.

  \item[fail-unknown-identifier.spl] Demonstrates the error message given when
  an undefined identifier occurs in a program.

  \item[fail-not-enough-function-arguments.spl] Demonstrates the error message
  given when a function is called with too few arguments.

  \item[fail-no-polymorphism-in-variables-lvalues.txt] Assigning to a global
  variable constrains its type, even if it is initialized with a polymorphic
  value.  Therefore, it is forbidden to assign values of different types to a
  global variable.

  \item[fail-no-polymorphism-in-variables-rvalues.spl] Using a global variable
  in an expression constrains its type, even if it could be polymorphic.  This
  is the tradeoff we had to make for assignments to be sound.

  \item[pass-assignment-to-function.spl] It is possible to bind functions to
  local variables, assign to them, and call them.

  \item[shouldfail-assignment-to-function.spl] It should be forbidden to assign
  to identifiers which are bound to global functions.  To be done.

  \item[pass-return-function.spl] A function can return another function.

  \item[fail-return-function.spl] It is not possible to directly call the return
  value of a function that returns another function.

\end{description}

\subsection{Examples from p1}

This section contains the compilation results for the provided examples.  One
of them had to be slightly modified, because it contained non-capitalized
boolen constants \texttt{true} and \texttt{false} instead of \texttt{True} and
\texttt{False}.

When parsing or type checking fails, the compiler prints an error message
indicating the cause of the error.  When both these phases succeed, the compiler
prettyprints the program, with inferred types instead of type annotations.

Function types in error messages are pretty-printed as a space separated list
of the argument types, followed by an arrow symbol, followed by the return
type.  For example, the type of the constant function is printed as \texttt{(a
b -> a)}, and the type of the main function as \texttt{( -> Void)}.

\begin{verbatim}
$ ./spl --typecheck -i examplePrograms/2D.spl
(Int, Int) foo(Int n)
{
  return (2, 2);
}

(Int, Int) transpose((Int, Int) p1, (Int, Int) p2)
{
  return ((fst(p1) + fst(p2)), (snd(p1) + snd(p2)));
}

(Int, Int) scale((Int, Int) p, Int scalar)
{
  return ((fst(p) * scalar), (snd(p) * scalar));
}



$ ./spl --typecheck -i examplePrograms/3D.spl
"Unknown identifier `first' at position 3:32"

$ ./spl --typecheck -i examplePrograms/arguments.spl
"Couldn't match expected type `(Int Bool [Int] -> [Int])' with actual type `( -> a)' at position 15:5"

$ ./spl --typecheck -i examplePrograms/booleans.spl
"Unknown identifier `null' at position 10:19"

$ ./spl --typecheck -i examplePrograms/bool.spl
Bool xor(Bool a, Bool b)
{
  return ((a || b) && !(a && b));
}

Bool implies(Bool a, Bool b)
{
  if( !a )
    return True;
  else
    return b;
}



$ ./spl --typecheck -i examplePrograms/empty.spl
Failed parsing 'examplePrograms/empty.spl' :
Expected  at position LineColPos 5 0 122 expecting one of [Comment, Whitespace, "[", "(", Identifier, "return", Identifier, Identifier, "while", "if", "{"] at 6:1 :
                              v
rseerd worden. Void main () { }  
                              ^



$ ./spl --typecheck -i examplePrograms/example10.spl
"Unknown identifier `null' at position 10:16"

$ ./spl --typecheck -i examplePrograms/Example.spl
"Couldn't match expected type `[Int]' with actual type `(a -> Int)' at position 21:55"

$ ./spl --typecheck -i examplePrograms/factorial.spl
Int facR(Int n)
{
  if( (n < 2) )
    return 1;
  else
    return (n * facR((n - 1)));
}

Int facI(Int n)
{
  Int r = 1;
  while( (n > 1) )
  {
    r = (r * n);
    n = (n - 1);
  }
  return r;
}

Void main()
{
  Int n = 0;
  Int facN = 1;
  Bool ok = True;
  while( (n < 20) )
  {
    facN = facR(n);
    if( ((facN != facI(n)) || (facN != facL(n))) )
    {
      print((n : (facN : (facI(n) : (facL(n) : [])))));
      ok = False;
    }
    else
    {
    }
    n = (n + 1);
  }
  print(ok);
}

Int facL(Int n)
{
  return product(fromTo(1, n));
}

Int product([Int] list)
{
  if( isEmpty(list) )
    return 1;
  else
    return (head(list) * product(tail(list)));
}

[Int] fromTo(Int from, Int to)
{
  if( (from <= to) )
    return (from : fromTo((from + 1), to));
  else
    return [];
}



$ ./spl --typecheck -i examplePrograms/Fib.spl
Int fib(Int n)
{
  if( (n < 2) )
    return 1;
  else
    return (fib((n - 1)) + fib((n - 2)));
}



$ ./spl --typecheck -i examplePrograms/integers.spl
Int abs(Int n)
{
  if( (n < 0) )
    return -n;
  else
    return n;
}



$ ./spl --typecheck -i examplePrograms/list.spl
Bool equals([Int] a, [Int] b)
{
  if( (isEmpty(a) && isEmpty(b)) )
    return True;
  else
  {
  }
  if( (isEmpty(a) || isEmpty(b)) )
    return False;
  else
  {
  }
  return ((head(a) == head(b)) && equals(tail(a), tail(b)));
}



$ ./spl --typecheck -i examplePrograms/lists.spl
[a] reverse([a] list)
{
  [a] accu = [];
  while( !isEmpty(list) )
  {
    accu = (head(list) : accu);
    list = tail(list);
  }
  return accu;
}

Int sum([Int] list)
{
  return (head(list) + sum(tail(list)));
}

Int product([Int] list)
{
  return (head(list) * product(tail(list)));
}

Void main()
{
  [Int] list = (1 : (3 : (5 : [])));
  print(sum(list));
  print(product(list));
}



$ ./spl --typecheck -i examplePrograms/mergeSort.spl
Int length([Int] list)
{
  if( isEmpty(list) )
    return 0;
  else
    return (1 + length(tail(list)));
}

[Int] append([Int] list, Int value)
{
  if( isEmpty(list) )
    return (value : []);
  else
    return (head(list) : append(tail(list), value));
}

([Int], [Int]) split_aux([Int] list, Int n)
{
  ([a], [a]) tl = split(tail(list), (n - 1));
  return ((head(list) : fst(tl)), snd(tl));
}

([Int], [Int]) split([Int] list, Int n)
{
  if( (isEmpty(list) || (n == 0)) )
    return ([], list);
  else
    return split_aux(list, n);
}

[Int] merge_sort_aux([Int] m)
{
  Int middle = (length(m) / 2);
  ([Int], [Int]) parts = split(m, middle);
  [Int] left = fst(parts);
  [Int] right = snd(parts);
  left = merge_sort(left);
  right = merge_sort(right);
  return merge(left, right);
}

[Int] merge_sort([Int] m)
{
  if( (isEmpty(m) || isEmpty(tail(m))) )
    return m;
  else
  {
  }
  return merge_sort_aux(m);
}

[Int] merge([Int] left, [Int] right)
{
  [Int] result = [];
  while( !(isEmpty(left) || !isEmpty(right)) )
  {
    if( !(isEmpty(left) && !isEmpty(right)) )
    {
      if( (head(left) <= head(right)) )
      {
        result = append(result, head(left));
        left = tail(left);
      }
      else
      {
        result = append(result, head(right));
        right = tail(right);
      }
    }
    else
      if( !isEmpty(left) )
      {
        result = append(result, head(left));
        left = tail(left);
      }
      else
        if( !isEmpty(right) )
        {
          result = append(result, head(right));
          right = tail(right);
        }
        else
        {
        }
  }
  return result;
}

Void main()
{
  [Int] list = (8 : (10 : (3 : (7 : (9 : (6 : (4 : (1 : (2 : (5 : []))))))))));
  print(merge_sort(list));
}



$ ./spl --typecheck -i examplePrograms/mklinik.spl
Int foobar()
{
  return -10;
}



$ ./spl --typecheck -i examplePrograms/op.spl
Int n = 5;

Bool op = (((1 + (n / 2)) - (n % 2)) < n);

Bool op2 = ((((1 + n) / 2) - (n % 2)) < n);



$ ./spl --typecheck -i examplePrograms/pass_nested_expr.spl
Int main()
{
  return 5;
}



$ ./spl --typecheck -i examplePrograms/problematic_programs.spl
"Couldn't match expected type `(Int Int -> Int)' with actual type `(a b -> Void)' at position 8:53"

$ ./spl --typecheck -i examplePrograms/problematic.spl
"Couldn't match expected type `Int' with actual type `( -> Int)' at position 10:16"

$ ./spl --typecheck -i examplePrograms/stress.spl
Failed parsing 'examplePrograms/stress.spl' :
Expected  at position LineColPos 10 1 367 expecting one of [Comment, Whitespace, "return", Identifier, Identifier, "while", "if", "{", "}"] at 11:2 :
                              v
rse as (!1):2, not !(1:2) */  [([foo],bar)] y = this_is_fine((1,(2,3)))
                              ^



$ ./spl --typecheck -i examplePrograms/SumProduct.spl
"Couldn't match expected type `([Bool] -> Bool)' with actual type `(a -> Int)' at position 6:22"

$ ./spl --typecheck -i examplePrograms/sum.spl
Failed parsing 'examplePrograms/sum.spl' :
Expected  at position LineColPos 25 13 346 expecting one of [Comment, Whitespace, "]"] at 26:14 :
                              v
}  Void main() {  print (sum([1:2:3:[]]));  print (sum1([1:2:3:[]]));  
                              ^



$ ./spl --typecheck -i examplePrograms/while.spl
Void keepGoingI(Int n)
{
  while( True )
  {
    n = (n + 1);
  }
}

Void keepGoingR(Int n)
{
  return keepGoingR((n + 1));
}



$ ./spl --typecheck -i examplePrograms/whitespaces.spl
Void CAPPS(Int X, Bool S)
{
  X = 0;
  S = True;
  return;
}

Void tabbed()
{
  return;
}



$ ./spl --typecheck -i examplePrograms/x.spl
a xMarksTheSpot(a x)
{
  return x;
}
\end{verbatim}

\bibliographystyle{plain}
\bibliography{computer_science}

\end{document}

% vim: textwidth=80
