\documentclass[a4paper]{article}

%\usepackage{mathptmx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}
%\usepackage[square]{natbib}

% needs debian package texlive-math-extra
\usepackage{stmaryrd} % for \llbracket, \rrbracket (scott brackets)

\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{matrix}

\newcommand{\arr}{\rightarrow}
\newcommand{\todo}[1]{\bigskip \noindent \emph{todo: #1}}
%\newcommand{\todo}[1]{}
\newcommand{\semantics}[1]{\llbracket #1 \rrbracket}

% church-style (explicit) abstraction. We adjust the spacing around the colon and dot
\newcommand{\church}[4]{#1 #2\!:\!#3\,.\,#4}

\newcommand{\curry}[3]{#1 #2\,.\,#3}

% something is of type something  x : A, we adjust the spacing
\newcommand{\oftype}[2]{#1\!:\!#2}

\begin{document}

\title{A Typechecker for SPL, the Simple~Programming~Language}
\author{Markus Klinik (s4220315)}
\maketitle

\begin{abstract}

This report describes design decisions and typing rules for the
implementation of the type checker for the course NWI-IMC004 Compiler
Construction.

\end{abstract}

\section{Implementation language}

The SPL parser and type checker are written in Haskell, because a
functional language is well-suited for the various programming tasks
that arise when implementing a compiler.

\begin{itemize}

  \item Traversing trees by pattern matching and recursion on algebraic
  data types is most convenient.

  \item Immutable data structures and sharing allow a style of
  programming that resembles mathematical definitions.  This comes in
  handy for example when an environment needs to be passed modified to
  a subcomputation, but the original environment is needed again later.

  \item Haskell has a rich set of standard and third-party libraries
  which allows focusing on the problem at hand.

\end{itemize}

\section{Grammar}

The Parser is implemented in a top-down style using the uu-parsinglib
parser combinator library.  The grammar is kept mostly unmodified,
making use of the backtracking features of uu-parsinglib.  Focus was
put more on conciseness of the implementation rather than run-time
performance.

There are two important changes to the grammar.  The first one is the
introduction of intermediate non-terminals to account for the different
precedence levels of binary operators.  These intermediate
non-terminals are not given names, they arise by mapping parser
constructing functions over a suitably nested list of strings, followed
by folding the result with left- and right chaining combinators,
according to their associativity.

The second change to the grammar is one left-factorization in the rule
for expressions, to get rid of backtracking when an expression in the
input starts with many opening parenthesis.

\section{Scoping rules}

Before getting to scoping rules, we need to discuss the role of type
annotations, and mutual recursion.

\subsection{Type annotations}

There are two different ways to interpret type
annotations \cite{TaPL}.  Consider the following two lambda-terms, one
in Curry-style without type annotations and the other one in
Church-style with type annotations.

\begin{IEEEeqnarray}{c}
\label{curryterm}\curry{\lambda}{f}{\curry{\lambda}{x}{f(f x)}}\\
\label{churchterm}\church{\lambda}{f}{a}{\church{\lambda}{x}{b}{f(f x)}}
\end{IEEEeqnarray}

When type checking term (\ref{curryterm}) in a polymorphic type system,
the type inference algorithm would infer that the term has type
$(a \arr a) \arr a \arr a$, and conclude that the term is
well typed.  For term (\ref{churchterm}), considered under the same
typing rules, the question arises what the meaning of the type
variables $a$ and $b$ is.  These two are possible:

\begin{enumerate}

 \item \label{interp_exists} There exists a substitution ${}^*$ for
 $a$, $b$, $c$ such that term (\ref{churchterm}) has type $(a \arr b
 \arr c)^*$.

 \item \label{interp_forall} For all substitutions ${}^{*_1}$ of $a$
 and $b$, there exists a substitution ${}^{*_2}$ of $c$ such that term
 (\ref{churchterm}) has type $(a^{*_1} \arr b^{*_1} \arr c^{*_2})$.

\end{enumerate}

Under the first interpretation, term (\ref{churchterm}) would
be well-typed, because clearly such a substitution exists.  Take $[a
\arr (\text{Int} \arr \text{Int}), b \arr \text{Int}, c \arr
\text{Int}]$.

Under the second interpretation, term (\ref{churchterm}) would not be
well-typed, because for the substitution $[a \arr \text{Int}, b \arr
\text{Int}]$, there is no substitution ${}^*$ for $c$ such that the term has
type $(\text{Int} \arr \text{Int} \arr c^*)$.

A similar term that would be well-typed under both the first and the second
interpretation is the following one:

\begin{IEEEeqnarray}{c}
\label{churchterm2}\church{\lambda}{f}{a \arr a}{\church{\lambda}{x}{a}{f(f x)}}
\end{IEEEeqnarray}

The grammar for SPL, as given in the first exercise, does not allow type
annotations of function types.  We therefore have to either choose the first
interpretation, or add function types to the grammar to choose the second
interpretation.  The first interpretation seemed more challenging, so the
present implementation of the SPL compiler cooses this one.

\subsection{Polymorphism and mutual recursion}



\end{document}

% vim: textwidth=80
