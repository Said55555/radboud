\documentclass[a4paper]{article}

%\usepackage{mathptmx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}
%\usepackage[square]{natbib}

% needs debian package texlive-math-extra
\usepackage{stmaryrd} % for \llbracket, \rrbracket (scott brackets)

\usepackage{bussproofs}
\def\defaultHypSeparation{\hskip .1in}

\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{matrix}

\newcommand{\arr}{\rightarrow}
\newcommand{\todo}[1]{\bigskip \noindent \emph{todo: #1}}
%\newcommand{\todo}[1]{}
\newcommand{\semantics}[1]{\llbracket #1 \rrbracket}

% church-style (explicit) abstraction. We adjust the spacing around the colon and dot
\newcommand{\church}[4]{#1 #2\!:\!#3\,.\,#4}

\newcommand{\curry}[3]{#1 #2\,.\,#3}

% something is of type something  x : A, we adjust the spacing
\newcommand{\oftype}[2]{#1\!:\!#2}

\begin{document}

\title{A Typechecker for SPL, the Simple~Programming~Language}
\author{Markus Klinik (s4220315)}
\maketitle

\begin{abstract}

This report describes design decisions and typing rules for the
implementation of the type checker for the course NWI-IMC004 Compiler
Construction.

\end{abstract}

\section{Implementation language}

The SPL parser and type checker are written in Haskell, because a
functional language is well-suited for the various programming tasks
that arise when implementing a compiler.

\begin{itemize}

  \item Traversing trees by pattern matching and recursion on algebraic
  data types is most convenient.

  \item Immutable data structures and sharing allow a style of
  programming that resembles mathematical definitions.  This comes in
  handy for example when an environment needs to be passed modified to
  a subcomputation, but the original environment is needed again later.

  \item Haskell has a rich set of standard and third-party libraries
  which allows focusing on the problem at hand.

\end{itemize}

\section{Grammar}

The Parser is implemented in a top-down style using the uu-parsinglib
parser combinator library.  The grammar is kept mostly unmodified,
making use of the backtracking features of uu-parsinglib.  Focus was
put more on conciseness of the implementation rather than run-time
performance.

There are three important changes to the grammar.  The first one is the
introduction of intermediate non-terminals to account for the different
precedence levels of binary operators.  These intermediate
non-terminals are not given names, they arise by mapping parser
constructing functions over a suitably nested list of strings, followed
by folding the result with left- and right chaining combinators,
according to their associativity.

The second change to the grammar is one left-factorization in the rule
for expressions, to get rid of backtracking when an expression in the
input starts with many opening parenthesis.

The third grammar change is due to scoping issues, and described in the next
section.

\section{Scoping rules}

Before getting to scoping rules, we need to discuss the role of type
annotations, and mutual recursion.

\subsection{Type annotations}

There are two different ways to interpret type
annotations \cite{TaPL}.  Consider the following two lambda-terms, one
in Curry-style without type annotations and the other one in
Church-style with type annotations.

\begin{IEEEeqnarray}{c}
\label{curryterm}\curry{\lambda}{f}{\curry{\lambda}{x}{f(f x)}}\\
\label{churchterm}\church{\lambda}{f}{a}{\church{\lambda}{x}{b}{f(f x)}}
\end{IEEEeqnarray}

When type checking term (\ref{curryterm}) in a polymorphic type system,
the type inference algorithm would infer that the term has type
$(a \arr a) \arr a \arr a$, and conclude that the term is
well typed.  For term (\ref{churchterm}), considered under the same
typing rules, the question arises what the meaning of the type
variables $a$ and $b$ is.  These two are possible:

\begin{enumerate}

 \item \label{interp_exists} There exists a substitution ${}^*$ for
 $a$, $b$, $c$ such that term (\ref{churchterm}) has type $(a \arr b
 \arr c)^*$.

 \item \label{interp_forall} For all substitutions ${}^{*_1}$ of $a$
 and $b$, there exists a substitution ${}^{*_2}$ of $c$ such that term
 (\ref{churchterm}) has type $(a^{*_1} \arr b^{*_1} \arr c^{*_2})$.

\end{enumerate}

Under the first interpretation, term (\ref{churchterm}) would
be well-typed, because clearly such a substitution exists.  Take $[a
\arr (\text{Int} \arr \text{Int}), b \arr \text{Int}, c \arr
\text{Int}]$.

Under the second interpretation, term (\ref{churchterm}) would not be
well-typed, because for the substitution $[a \arr \text{Int}, b \arr
\text{Int}]$, there is no substitution ${}^*$ for $c$ such that the term has
type $(\text{Int} \arr \text{Int} \arr c^*)$.

A similar term that would be well-typed under both the first and the second
interpretation is the following one:

\begin{IEEEeqnarray}{c}
\label{churchterm2}\church{\lambda}{f}{a \arr a}{\church{\lambda}{x}{a}{f(f x)}}
\end{IEEEeqnarray}

The grammar for SPL, as given in the first exercise, does not allow type
annotations of function types.  We therefore have to either choose the first
interpretation, or add function types to the grammar to choose the second
interpretation.  The first interpretation seemed more challenging, so the
present implementation of the SPL compiler chooses this one.

\subsection{Polymorphism and mutual recursion}

When inferring the type of a set of mutually recursive functions, all
constraints that arise in the bodies of the functions have to be unified
simultaneously.  Otherwise, the types of the functions become too general.
Consider the following mutually recursive functions $f$ and $g$.

\begin{verbatim}
a f(b x, c y) { return g(y, x); }
a g(b x, c y) { return f(x, y); }
\end{verbatim}

The type of both of them must be $\forall a b . (a \arr a \arr b)$, but if the
type inference algorithm would introduce $f$ all-quantified into the context
before calculating the constraints of $g$, it would infer the type $\forall a b
c .  (a \arr b \arr c)$ for both $f$ and $g$.

On the other hand, the constraints of functions which are not mutually recursive
must never be unified simultaneously, because otherwise they would get types
which are not general enough.  Consider the following example.

\begin{verbatim}
a id(a x) { return x; }
Void h() { id(10); return; }
\end{verbatim}

If the type inference algorithm would unify the types of \emph{h} and \emph{id}
simultaneously, it would infer the type $(\text{Int} \arr \text{Int})$ for
\emph{id}.  This means that the type inference algorithm must first infer the
type of \emph{id} separately, introduce it all-quantified as $\forall a . (a
\arr a)$ to the context, and then infer the type of \emph{h}.

It therefore seems that no matter which of the above we choose, the following
program would give either a type error for \emph{id} or too general types to
\emph{f} and \emph{g}.

\begin{verbatim}
a id(a x) { return x; }
a f(b x, c y) { id(10); return g(y, x); }
a g(b x, c y) { id(True); return f(x, y); }
\end{verbatim}

It appears that we must choose one of the following alternatives.

\begin{itemize}
  
  \item Forbid mutual recursion.

  \item Require forward declarations, like in C.

  \item Let the programmer explicitly specify the functions whose types should
  be unified simultaneously.

  \item Make the type checker analyse dependencies of function definitions to
  find cycles and thus automatically determine which functions to unify
  simultaneously.

\end{itemize}

The first alternative would result in a much easier implementation of the type
checker, at the cost of flexibility for the programmer.

The second alternative would run counter to the idea of type inference.

The third alternative, realizable for example by explicit let-bindings which
allow several bindings to be defined at once, places the burden of resolving
dependencies on the programmer.

Clearly, the fourth alternative would be preferable, and it should indeed be
possible to automatically determine dependencies between functions by just
looking at the free variables that occur in the function bodies.

The implementation at hand chooses the third alternative, mostly because of time
constraints due to upcoming deadlines.

\subsection{Polymorphism and assignments}

Another issue is polymorphic type inference in presence of assignments.  The
question is whether to all-quantify free type variables in local and global
variables.  To illustrate the problem, consider the following, not well-typed,
program.

\begin{verbatim}
fun f() {
  var x = [];
  x = 1:[];
  x = True:[];
}
\end{verbatim}

If the type checker would introduce $x$ all-quantified to the environment when
type checking the function body, $x$ would be of type $\forall a . [a]$, which
could be specialized to $[\text{Int}]$ in the first assignment, and to
$[\text{Bool}]$ in the second.  Clearly, this is unsound.  Pierce, in his
chapter about mutable references \cite{TaPL}, solves this problem by
all-quantifying the type of an identifier only if its initializer is a syntactic
value.  He argues that this restriction has no big impact on usability.  In his
language, reference cell constructors are not values, so identifiers initialized
with a reference cell are never all-quantified.  In SPL, as variables are always
mutable, every variable is always implicitly a reference cell, so by adopting
the \emph{value restriction} in the type checker at hand, the types of variables
are never all-quantified.  This gives the desired type error for the program
above, with the tradeoff that programs like the following, in which an identifier
is never assigned to, also give type errors. This is because the type of $x$ gets
constrained to both $[\text{Int}]$ and $[\text{Bool}]$.

\begin{verbatim}
fun f() {
  var x = [];
  return (1:x, True:x);
}
\end{verbatim}

The scoping rules implied by the design
decisions discussed so far are described in the following section.

\subsection{Scoping rules}

First, we change the production rule for SPL programs as follows:

\begin{IEEEeqnarray*}{rCl}
\text{Prog} & ::= & \text{Decl}\!+\ \text{Scope}*\\
\text{Scope} & ::= & `\text{=====}`\ \text{Decl}\!+
\end{IEEEeqnarray*}

An SPL program is therefore a list of blocks of declarations, which are
separated by a token consisting of five equal signs.  This is of course to be
considered as a proof-of-concept, rather than something that can be handed out
to real programmers.

The scoping rules for global identifiers are then as follows.

\begin{itemize}

  \item All identifiers within the same block of declarations are visible
  simultaneously to each other.

  \item Identifiers from earlier blocks are visible in later blocks, but not
  vice versa.

  \item When a name collision occurs, the earlier declaration is silently
  shadowed.  There are no error or warning messages yet.

\end{itemize}

For local identifiers, there is only one scoping rule.

\begin{itemize}

  \item All local identifiers defined in a function body are visible
  simultaneously, inside the whole function body.

\end{itemize}

This way, the problematic example with mutual recursion from above can be
correctly typed, when given as follows.

\begin{verbatim}
a id(a x) { return x; }
=====
a f(b x, c y) { id(10); return g(y, x); }
a g(b x, c y) { id(True); return f(x, y); }
\end{verbatim}

The function \emph{id}, gets type $\forall a .  (a \arr a)$, and $f$ and $g$
both get type $\forall a b . (a \arr a \arr b)$.


\section{Typing rules}

The typing relation is a 4-place relation of an environment $\Gamma$, a
syntactic construct, a type and a substitution.  We read a typing judgement
$\Gamma \vdash \oftype{e}{\sigma} | *$ as ``In the environment $\Gamma$, the
syntactic construct $e$ has type $\sigma$, under the substitution $*$''.  The
premises of the typing rules are to be read from left to right.

The typing relation is defined by recursion on the abstract syntax as follows.

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, \text{Bool})$}
\LeftLabel{(Bool)}
\RightLabel{$b \in \{\text{True}, \text{False}\}$}
\UnaryInfC{$\Gamma \vdash \oftype{b}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, \text{Int})$}
\LeftLabel{(Int)}
\RightLabel{$i \in \mathbb{Z}$}
\UnaryInfC{$\Gamma \vdash \oftype{i}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, a)$}
\LeftLabel{(empty list)}
\RightLabel{$a$ fresh}
\UnaryInfC{$\vdash \oftype{[]}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e_1}{a_1} | *_1$}
\AxiomC{$\Gamma^{*_1} \vdash \oftype{e_2}{a_2} | *_2$}
\AxiomC{$*_3 = \mathcal{U}(\sigma^{*_2 \circ *_1}, (a_1, a_2)^{*_2 \circ *_1})$}
\LeftLabel{(tuple)}
\RightLabel{$a_1$, $a_2$ fresh}
\TrinaryInfC{$\Gamma \vdash \oftype{(e_1, e_2)}{\sigma} | *_3 \circ *_2 \circ *_1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\tau = \Gamma(i)$}
\AxiomC{$* = \mathcal{U}(\sigma, \tau)$}
\LeftLabel{(identifier)}
\RightLabel{$i$ identifier}
\BinaryInfC{$\Gamma \vdash \oftype{i}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{\odot(e_1, e_2)}{\sigma} | *$}
\LeftLabel{(binary operator)}
\RightLabel{$\odot$ binary operator}
\UnaryInfC{$\Gamma \vdash \oftype{e_1 \odot e_2}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{\bullet(e)}{\sigma} | *$}
\LeftLabel{(unary operator)}
\RightLabel{$\bullet$ unary operator}
\UnaryInfC{$\Gamma \vdash \oftype{\bullet e}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\tau = \Gamma(f)$}
\AxiomC{$* = \mathcal{U}(\tau, (\vec{\alpha} \arr \sigma))$}
\AxiomC{$\Gamma^*\ \vec{\vdash}\ \oftype{\vec{e}}{(\vec{\alpha})^*} | *_1$}
\LeftLabel{(function call expression)}
\RightLabel{$\vec{\alpha}$ fresh and $|\vec{\alpha}| = |\vec{e}|$}
\TrinaryInfC{$\Gamma \vdash \oftype{f(\vec{e})}{\sigma} | *_1 \circ\,*$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, \text{Void})$}
\LeftLabel{(return Void)}
\UnaryInfC{$\Gamma \vdash \oftype{\text{return}}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e}{\sigma} | *$}
\LeftLabel{(return a value)}
\UnaryInfC{$\Gamma \vdash \oftype{\text{return e}}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma       \vdash \oftype{e}{\text{Bool}} | *_1$}
\AxiomC{$\Gamma^{*_1} \vdash \oftype{s_1}{\sigma^{*_1}} | *_2$}
\AxiomC{$\Gamma^{*_2 \circ *_1} \vdash \oftype{s_2}{\sigma^{*_2 \circ *_1}} | *_3$}
\LeftLabel{(if-then-else)}
\TrinaryInfC{$\Gamma \vdash \oftype{\text{if}(e) s_1 \text{ else } s_2}{\sigma} | *_3 \circ *_2 \circ\,*_1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vec{\vdash}\ \oftype{\vec{s}}{\vec{\sigma}} | *$}
\LeftLabel{(statement block)}
\RightLabel{$\vec{\sigma} = \langle\sigma, \sigma, \ldots, \sigma\rangle$}
\UnaryInfC{$\Gamma \vdash \oftype{\vec{s}}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e}{\text{Bool}} | *_1$}
\AxiomC{$\Gamma^{*_1} \vdash \oftype{s}{\sigma^{*_1}} | *_2$}
\LeftLabel{(while)}
\BinaryInfC{$\Gamma \vdash \oftype{\text{while}(e) s}{\sigma} | *_2 \circ *_1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\tau = \Gamma(i)$}
\AxiomC{$\Gamma \vdash \oftype{e}{\tau} | *$}
\LeftLabel{(assignment)}
\BinaryInfC{$\Gamma \vdash \oftype{i := e}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{f(\vec{e})}{\alpha} | *$}
\LeftLabel{(function call statement)}
\RightLabel{$\alpha$ fresh}
\UnaryInfC{$\Gamma \vdash \oftype{f(\vec{e})}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e}{\sigma} | *$}
\LeftLabel{(variable declaration)}
\UnaryInfC{$\Gamma \vdash \oftype{i = e}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$P_1$}
\AxiomC{$P_2$}
\AxiomC{$P_3$}
\LeftLabel{(function declaration)}
\RightLabel{$\vec{\beta} = \text{derive}(\vec{\alpha}), \beta = \text{derive}(\alpha)$}
\TrinaryInfC{$\Gamma \vdash \oftype{
  \alpha f(\oftype{\vec{i}}{\vec{\alpha}})
  \vec{l} s}{\sigma} | *_3 \circ *_2 \circ\,*_1$}
\end{prooftree}

Where the premises $P_1$ - $P_3$ are:
\begin{IEEEeqnarray*}{rCl}
(P_1) & : & (*_1, \Gamma') = \text{intro}(\vec{l}, (\Gamma, \oftype{\vec{i}}{\vec{\beta}}))\\
(P_2) & : & \Gamma' \vdash \oftype{s}{\beta^{*_1}} | *_2\\
(P_3) & : & *_3 = \mathcal{U}(\sigma^{*_2 \circ *_1}, (\vec{\beta} \arr \beta)^{*_2 \circ *_1})
\end{IEEEeqnarray*}

\begin{prooftree}
\AxiomC{$(\_\,, \Gamma') = \text{intro}(\vec{d}_1)$}
\AxiomC{$\Gamma' \vdash \oftype{\langle \vec{d}_2, \ldots, \vec{d}_n \rangle}{\sigma} | *$}
\LeftLabel{(program)}
\BinaryInfC{$\Gamma \vdash \oftype{\langle \vec{d}_1, \vec{d}_2, \ldots, \vec{d}_n \rangle}{\sigma} | *$}
\end{prooftree}

Looking up the type of an identifier $i$ in an environment $\Gamma$ is defined
as follows.

\begin{equation*}
\Gamma(i) = \text{if } (i, \forall \vec{\alpha}.\tau) \in \Gamma \text{ then } \tau[\vec{\alpha} \mapsto
\vec{\beta}], \text{ where } \vec{\beta} \text{ fresh}
\end{equation*}

That is, we generate a fresh type variable for each bound type variable (if any)
in the type of $i$, then we remove the quantifier and replace all
previously bound variables with the fresh ones.

Inferring the types of a vector of expressions is defined by recursion on the
length of the vector as follows. It is assumed that $|\vec{e}| =
|\vec{\alpha}|$.

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma\ \vec{\vdash}\ \oftype{\langle\rangle}{\langle\rangle} | \text{id}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e_1}{\alpha_1}|*$}
\AxiomC{$\Gamma^*\ \vec{\vdash}\ \oftype{\langle e_2, \ldots, e_n
\rangle}{(\langle \alpha_2, \ldots, \alpha_n\rangle)^*}|*_1$}
\BinaryInfC{$\Gamma\ \vec{\vdash}\ \oftype{\langle e_1, e_2, \ldots,
e_n\rangle}{\langle \alpha_1, \alpha_2, \ldots, \alpha_n\rangle} | *_1 \circ\,*$}
\end{prooftree}

In the rule (function call statement), we use the rule (function call
expression) in the premise, and discard the inferred type.

The function \emph{derive}, used in the rule (function declaration) and by the
function \emph{intro}, generates fresh types, similar to \emph{fresh}, but
\emph{derive} uses the type annotation present in the abstract syntax tree to
generate a fresh type of that shape.  The same variables in the type annotation
become the same fresh type variables.  For example, if $(a \arr b \arr a)$ is a
type annotation, then \emph{derive}$(a \arr b \arr a)$ returns $(c \arr d \arr
c)$, with $c$ and $d$ fresh.

The function \emph{intro}, used in rules (function declaration) and (program),
is the clause of the type inference function that we have seen in the lecture on
slide 13, ``Multiple recursion (2)'', with these differences:

\begin{itemize}

  \item Instead of fresh type variables, it uses \emph{derive}.

  \item Free type variables in types of variables are never quantified.

  \item Instead of recursing into the body of the let binding, \emph{intro}
  returns the calculated modified environment and substitution.

\end{itemize}

In the rule (program), each $\vec{d}_i$ is a list of declarations.  Each of
these lists is type checked simultaneously, then added to the environment.
These two things are done by \emph{intro}.  The rest of the program is type
checked in the modified environment returned by \emph{intro}.

Type checking starts in an initial environment which is pre-loaded with the
definitions for the built in functions and operators.  Both binary and unary
operators are treated as function calls, so their type is looked up in the
environment.

\section{Further work}

There are a few open points in the current implementation.

\begin{itemize}

  \item All identifiers are tracked in the same environment.  Therefore, the
  type checker doesn't forbid assignments to identifiers which refer to
  functions, or even built-in functions.

  \item There are no warnings or errors when name clashes occur.  The previously
  defined identifier is silently shadowed.

  \item Requiring the programmer to explicitly separate blocks of declarations
  could be automated by a dependency analysis.

  \item Putting the inferred type information into the abstract syntax tree is
  not implemented yet.  Instead, when type inference is successful, all global
  definitions are printed on standard output, together with their inferred type.
  Type variables in the inferred type are pretty-printed so they don't show up
  as numbers.

\end{itemize}


\section{Examples}

This section contains the compilation results for the provided examples.  Some
of them had to be slightly modified, because they contained non-capitalized
boolen constants \texttt{true} and \texttt{false} instead of \texttt{True} and
\texttt{False}.

When parsing or type checking fails, the compiler prints an error message
indicating the cause of the error.  When both these phases succeed, the compiler
prints all global definitions, together with their inferred type.

Function types are pretty-printed as a space separated list of the argument
types, followed by an arrow symbol, followed by the return type.  For example,
the type of the constant function is printed as \texttt{(a b -> a)}, and the
type of the main function as \texttt{( -> Void)}.

\begin{verbatim}
$ ./spl --typecheck -i examplePrograms/2D.spl
scale : ((Int, Int) Int -> (Int, Int))
transpose : ((Int, Int) (Int, Int) -> (Int, Int))
foo : (Int -> (Int, Int))


$ ./spl --typecheck -i examplePrograms/3D.spl
"Unknown identifier `first' at position 3:32"

$ ./spl --typecheck -i examplePrograms/arguments.spl
"Couldn't match expected type `(Int Bool [Int] -> [Int])' with actual type `( -> a)' at position 15:5"

$ ./spl --typecheck -i examplePrograms/booleans.spl
"Unknown identifier `null' at position 10:19"

$ ./spl --typecheck -i examplePrograms/bool.spl
implies : (Bool Bool -> Bool)
xor : (Bool Bool -> Bool)


$ ./spl --typecheck -i examplePrograms/empty.spl
Failed parsing 'examplePrograms/empty.spl' :
Expected  at position LineColPos 5 0 122 expecting one of [Comment, Whitespace, "[", "(", Identifier, "return", Identifier, Identifier, "while", "if", "{"] at 6:1 :
                              v
rseerd worden. Void main () { }  
                              ^



$ ./spl --typecheck -i examplePrograms/example10.spl
"Unknown identifier `null' at position 10:16"

$ ./spl --typecheck -i examplePrograms/Example.spl
"Couldn't match expected type `[Int]' with actual type `(a -> Int)' at position 21:55"

$ ./spl --typecheck -i examplePrograms/factorial.spl
fromTo : (Int Int -> [Int])
product : ([Int] -> Int)
facL : (Int -> Int)
main : ( -> Void)
facI : (Int -> Int)
facR : (Int -> Int)


$ ./spl --typecheck -i examplePrograms/Fib.spl
fib : (Int -> Int)


$ ./spl --typecheck -i examplePrograms/integers.spl
abs : (Int -> Int)


$ ./spl --typecheck -i examplePrograms/list.spl
equals : ([Int] [Int] -> Bool)


$ ./spl --typecheck -i examplePrograms/lists.spl
main : ( -> Void)
product : ([Int] -> Int)
sum : ([Int] -> Int)
reverse : ([a] -> [a])


$ ./spl --typecheck -i examplePrograms/mergeSort.spl
main : ( -> Void)
merge : ([Int] [Int] -> [Int])
merge_sort : ([Int] -> [Int])
merge_sort_aux : ([Int] -> [Int])
split : ([Int] Int -> ([Int], [Int]))
split_aux : ([Int] Int -> ([Int], [Int]))
append : ([Int] Int -> [Int])
length : ([Int] -> Int)


$ ./spl --typecheck -i examplePrograms/mklinik.spl
foobar : ( -> Int)


$ ./spl --typecheck -i examplePrograms/op.spl
op2 : Bool
op : Bool
n : Int


$ ./spl --typecheck -i examplePrograms/pass_nested_expr.spl
main : ( -> Int)


$ ./spl --typecheck -i examplePrograms/problematic_programs.spl
"Couldn't match expected type `(Int Int -> Int)' with actual type `(a b -> Void)' at position 8:53"

$ ./spl --typecheck -i examplePrograms/problematic.spl
"Couldn't match expected type `Int' with actual type `( -> Int)' at position 10:16"

$ ./spl --typecheck -i examplePrograms/stress.spl
Failed parsing 'examplePrograms/stress.spl' :
Expected  at position LineColPos 10 1 367 expecting one of [Comment, Whitespace, "return", Identifier, Identifier, "while", "if", "{", "}"] at 11:2 :
                              v
rse as (!1):2, not !(1:2) */  [([foo],bar)] y = this_is_fine((1,(2,3)))
                              ^



$ ./spl --typecheck -i examplePrograms/SumProduct.spl
"Couldn't match expected type `([Bool] -> Bool)' with actual type `(a -> Int)' at position 6:22"

$ ./spl --typecheck -i examplePrograms/sum.spl
Failed parsing 'examplePrograms/sum.spl' :
Expected  at position LineColPos 25 13 346 expecting one of [Comment, Whitespace, "]"] at 26:14 :
                              v
}  Void main() {  print (sum([1:2:3:[]]));  print (sum1([1:2:3:[]]));  
                              ^



$ ./spl --typecheck -i examplePrograms/while.spl
keepGoingR : (Int -> Void)
keepGoingI : (Int -> Void)


$ ./spl --typecheck -i examplePrograms/whitespaces.spl
tabbed : ( -> Void)
CAPPS : (Int Bool -> Void)


$ ./spl --typecheck -i examplePrograms/x.spl
xMarksTheSpot : (a -> a)
\end{verbatim}


\end{document}

% vim: textwidth=80
