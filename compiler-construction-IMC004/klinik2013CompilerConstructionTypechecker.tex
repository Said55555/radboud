\documentclass[a4paper]{article}

%\usepackage{mathptmx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}
%\usepackage[square]{natbib}

% needs debian package texlive-math-extra
\usepackage{stmaryrd} % for \llbracket, \rrbracket (scott brackets)

\usepackage{bussproofs}
\def\defaultHypSeparation{\hskip .1in}

\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{matrix}

\newcommand{\arr}{\rightarrow}
\newcommand{\todo}[1]{\bigskip \noindent \emph{todo: #1}}
%\newcommand{\todo}[1]{}
\newcommand{\semantics}[1]{\llbracket #1 \rrbracket}

% church-style (explicit) abstraction. We adjust the spacing around the colon and dot
\newcommand{\church}[4]{#1 #2\!:\!#3\,.\,#4}

\newcommand{\curry}[3]{#1 #2\,.\,#3}

% something is of type something  x : A, we adjust the spacing
\newcommand{\oftype}[2]{#1\!:\!#2}

\begin{document}

\title{A Typechecker for SPL, the Simple~Programming~Language}
\author{Markus Klinik (s4220315)}
\maketitle

\begin{abstract}

This report describes design decisions and typing rules for the
implementation of the type checker for the course NWI-IMC004 Compiler
Construction.

\end{abstract}

\section{Implementation language}

The SPL parser and type checker are written in Haskell, because a
functional language is well-suited for the various programming tasks
that arise when implementing a compiler.

\begin{itemize}

  \item Traversing trees by pattern matching and recursion on algebraic
  data types is most convenient.

  \item Immutable data structures and sharing allow a style of
  programming that resembles mathematical definitions.  This comes in
  handy for example when an environment needs to be passed modified to
  a subcomputation, but the original environment is needed again later.

  \item Haskell has a rich set of standard and third-party libraries
  which allows focusing on the problem at hand.

\end{itemize}

\section{Grammar}

The Parser is implemented in a top-down style using the uu-parsinglib
parser combinator library.  The grammar is kept mostly unmodified,
making use of the backtracking features of uu-parsinglib.  Focus was
put more on conciseness of the implementation rather than run-time
performance.

There are three important changes to the grammar.  The first one is the
introduction of intermediate non-terminals to account for the different
precedence levels of binary operators.  These intermediate
non-terminals are not given names, they arise by mapping parser
constructing functions over a suitably nested list of strings, followed
by folding the result with left- and right chaining combinators,
according to their associativity.

The second change to the grammar is one left-factorization in the rule
for expressions, to get rid of backtracking when an expression in the
input starts with many opening parenthesis.

The third grammar change is due to scoping issues, and described in the next
section.

\section{Scoping rules}

Before getting to scoping rules, we need to discuss the role of type
annotations, and mutual recursion.

\subsection{Type annotations}

There are two different ways to interpret type
annotations \cite{TaPL}.  Consider the following two lambda-terms, one
in Curry-style without type annotations and the other one in
Church-style with type annotations.

\begin{IEEEeqnarray}{c}
\label{curryterm}\curry{\lambda}{f}{\curry{\lambda}{x}{f(f x)}}\\
\label{churchterm}\church{\lambda}{f}{a}{\church{\lambda}{x}{b}{f(f x)}}
\end{IEEEeqnarray}

When type checking term (\ref{curryterm}) in a polymorphic type system,
the type inference algorithm would infer that the term has type
$(a \arr a) \arr a \arr a$, and conclude that the term is
well typed.  For term (\ref{churchterm}), considered under the same
typing rules, the question arises what the meaning of the type
variables $a$ and $b$ is.  These two are possible:

\begin{enumerate}

 \item \label{interp_exists} There exists a substitution ${}^*$ for
 $a$, $b$, $c$ such that term (\ref{churchterm}) has type $(a \arr b
 \arr c)^*$.

 \item \label{interp_forall} For all substitutions ${}^{*_1}$ of $a$
 and $b$, there exists a substitution ${}^{*_2}$ of $c$ such that term
 (\ref{churchterm}) has type $(a^{*_1} \arr b^{*_1} \arr c^{*_2})$.

\end{enumerate}

Under the first interpretation, term (\ref{churchterm}) would
be well-typed, because clearly such a substitution exists.  Take $[a
\arr (\text{Int} \arr \text{Int}), b \arr \text{Int}, c \arr
\text{Int}]$.

Under the second interpretation, term (\ref{churchterm}) would not be
well-typed, because for the substitution $[a \arr \text{Int}, b \arr
\text{Int}]$, there is no substitution ${}^*$ for $c$ such that the term has
type $(\text{Int} \arr \text{Int} \arr c^*)$.

A similar term that would be well-typed under both the first and the second
interpretation is the following one:

\begin{IEEEeqnarray}{c}
\label{churchterm2}\church{\lambda}{f}{a \arr a}{\church{\lambda}{x}{a}{f(f x)}}
\end{IEEEeqnarray}

The grammar for SPL, as given in the first exercise, does not allow type
annotations of function types.  We therefore have to either choose the first
interpretation, or add function types to the grammar to choose the second
interpretation.  The first interpretation seemed more challenging, so the
present implementation of the SPL compiler chooses this one.

\subsection{Polymorphism and mutual recursion}

When inferring the type of a set of mutually recursive functions, all
constraints that arise in the bodies of the functions have to be unified
simultaneously.  Otherwise, the types of the functions become too general.
Consider the following mutually recursive functions $f$ and $g$.

\begin{verbatim}
a f(b x, c y) { return g(y, x); }
a g(b x, c y) { return f(x, y); }
\end{verbatim}

The type of both of them must be $\forall a b . (a \arr a \arr b)$, but if the
type inference algorithm would introduce $f$ all-quantified into the context
before calculating the constraints of $g$, it would infer the type $\forall a b
c .  (a \arr b \arr c)$ for both $f$ and $g$.

On the other hand, the constraints of functions which are not mutually recursive
must never be unified simultaneously, because otherwise they would get types
which are not general enough.  Consider the following example.

\begin{verbatim}
a id(a x) { return x; }
Void h() { id(10); return; }
\end{verbatim}

If the type inference algorithm would unify the types of \emph{h} and \emph{id}
simultaneously, it would infer the type $(\text{Int} \arr \text{Int})$ for
\emph{id}.  This means that the type inference algorithm must first infer the
type of \emph{id} separately, introduce it all-quantified as $\forall a . (a
\arr a)$ to the context, and then infer the type of \emph{h}.

It therefore seems that no matter which of the above we choose, the following
program would give either a type error for \emph{id} or too general types to
\emph{f} and \emph{g}.

\begin{verbatim}
a id(a x) { return x; }
a f(b x, c y) { id(10); return g(y, x); }
a g(b x, c y) { id(True); return f(x, y); }
\end{verbatim}

It appears that we must choose one of the following alternatives.

\begin{itemize}
  
  \item Forbid mutual recursion.

  \item Require forward declarations, like in C.

  \item Let the programmer explicitly specify the functions whose types should
  be unified simultaneously.

  \item Make the type checker analyse dependencies of function definitions to
  find cycles and thus automatically determine which functions to unify
  simultaneously.

\end{itemize}

The first alternative would result in a much easier implementation of the type
checker, at the cost of flexibility for the programmer.

The second alternative would run counter to the idea of type inference.

The third alternative, realizable for example by explicit let-bindings which
allow several bindings to be defined at once, places the burden of resolving
dependencies on the programmer.

Clearly, the fourth alternative would be preferable, and it should indeed be
possible to automatically determine dependencies between functions by just
looking at the free variables that occur in the function bodies.

The implementation at hand chooses the third alternative, mostly because of time
constraints due to upcoming deadlines.

\subsection{Polymorphism and assignments}

Another issue is polymorphic type inference in presence of assignments.  The
question is whether to all-quantify free type variables in local and global
variables.  To illustrate the problem, consider the following, not well-typed,
program.

\begin{verbatim}
fun f() {
  var x = [];
  x = 1:[];
  x = True:[];
}
\end{verbatim}

If the type checker would introduce $x$ all-quantified to the environment when
type checking the function body, $x$ would be of type $\forall a . [a]$, which
could be specialized to $[\text{Int}]$ in the first assignment, and to
$[\text{Bool}]$ in the second.  Clearly, this is unsound.  Pierce, in his
chapter about mutable references \cite{TaPL}, solves this problem by
all-quantifying the type of an identifier only if its initializer is a syntactic
value.  He argues that this restriction has no big impact on usability.  In his
language, reference cell constructors are not values, so identifiers initialized
with a reference cell are never all-quantified.  In SPL, as variables are always
mutable, every variable is always implicitly a reference cell, so by adopting
the \emph{value restriction} in the type checker at hand, the types of variables
are never all-quantified.  This gives the desired type error for the program
above, with the tradeoff that programs like the following, in which an identifier
is never assigned to, also give type errors. This is because the type of $x$ gets
constrained to both $[\text{Int}]$ and $[\text{Bool}]$.

\begin{verbatim}
fun f() {
  var x = [];
  return (1:x, True:x);
}
\end{verbatim}

The scoping rules implied by the design
decisions discussed so far are described in the following section.

\subsection{Scoping rules}

First, we change the production rule for SPL programs as follows:

\begin{IEEEeqnarray*}{rCl}
\text{Prog} & ::= & \text{Decl}\!+\ \text{Scope}*\\
\text{Scope} & ::= & `\text{=====}`\ \text{Decl}\!+
\end{IEEEeqnarray*}

An SPL program is therefore a list of blocks of declarations, which are
separated by a token consisting of five equal signs.  This is of course to be
considered as a proof-of-concept, rather than something that can be handed out
to real programmers.

The scoping rules for global identifiers are then as follows.

\begin{itemize}

  \item All identifiers within the same block of declarations are visible
  simultaneously to each other.

  \item Identifiers from earlier blocks are visible in later blocks, but not
  vice versa.

  \item When a name collision occurs, the earlier declaration is silently
  shadowed.  There are no error or warning messages yet.

\end{itemize}

For local identifiers, there is only one scoping rule.

\begin{itemize}

  \item All local identifiers defined in a function body are visible
  simultaneously, inside the whole function body.

\end{itemize}

This way, the problematic example with mutual recursion from above can be
correctly typed, when given as follows.

\begin{verbatim}
a id(a x) { return x; }
=====
a f(b x, c y) { id(10); return g(y, x); }
a g(b x, c y) { id(True); return f(x, y); }
\end{verbatim}

The function \emph{id}, gets type $\forall a .  (a \arr a)$, and $f$ and $g$
both get type $\forall a b . (a \arr a \arr b)$.


\section{Typing rules}

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, \text{Bool})$}
\LeftLabel{(Bool)}
\RightLabel{$b \in \{\text{True}, \text{False}\}$}
\UnaryInfC{$\Gamma \vdash \oftype{b}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, \text{Int})$}
\LeftLabel{(Int)}
\RightLabel{$i \in \mathbb{Z}$}
\UnaryInfC{$\Gamma \vdash \oftype{i}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, a)$}
\LeftLabel{(empty list)}
\RightLabel{$a$ fresh}
\UnaryInfC{$\vdash \oftype{[]}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e_1}{a_1} | *_1$}
\AxiomC{$\Gamma^{*_1} \vdash \oftype{e_2}{a_2} | *_2$}
\AxiomC{$*_3 = \mathcal{U}(\sigma^{*_2 \circ *_1}, (a_1, a_2)^{*_2 \circ *_1})$}
\LeftLabel{(tuple)}
\RightLabel{$a_1$, $a_2$ fresh}
\TrinaryInfC{$\Gamma \vdash \oftype{(e_1, e_2)}{\sigma} | *_3 \circ *_2 \circ *_1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\tau = \Gamma(i)$}
\AxiomC{$* = \mathcal{U}(\sigma, \tau)$}
\LeftLabel{(identifier)}
\RightLabel{$i$ identifier}
\BinaryInfC{$\Gamma \vdash \oftype{i}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{\odot(e_1, e_2)}{\sigma} | *$}
\LeftLabel{(binary operator)}
\RightLabel{$\odot$ binary operator}
\UnaryInfC{$\Gamma \vdash \oftype{e_1 \odot e_2}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{\bullet(e)}{\sigma} | *$}
\LeftLabel{(unary operator)}
\RightLabel{$\bullet$ unary operator}
\UnaryInfC{$\Gamma \vdash \oftype{\bullet e}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\tau = \Gamma(f)$}
\AxiomC{$* = \mathcal{U}(\tau, (\vec{\alpha} \arr \sigma))$}
\AxiomC{$\Gamma^*\ \vec{\vdash}\ \oftype{\vec{e}}{(\vec{\alpha})^*} | *_1$}
\LeftLabel{(function call expression)}
\RightLabel{$\vec{\alpha}$ fresh and $|\vec{\alpha}| = |\vec{e}|$}
\TrinaryInfC{$\Gamma \vdash \oftype{f(\vec{e})}{\sigma} | *_1 \circ\,*$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$* = \mathcal{U}(\sigma, \text{Void})$}
\LeftLabel{(return Void)}
\UnaryInfC{$\Gamma \vdash \oftype{\text{return}}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e}{\sigma} | *$}
\LeftLabel{(return a value)}
\UnaryInfC{$\Gamma \vdash \oftype{\text{return e}}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma       \vdash \oftype{e}{\text{Bool}} | *_1$}
\AxiomC{$\Gamma^{*_1} \vdash \oftype{s_1}{\sigma^{*_1}} | *_2$}
\AxiomC{$\Gamma^{*_2 \circ *_1} \vdash \oftype{s_2}{\sigma^{*_2 \circ *_1}} | *_3$}
\LeftLabel{(if-then-else)}
\TrinaryInfC{$\Gamma \vdash \oftype{\text{if}(e) s_1 \text{ else } s_2}{\sigma} | *_3 \circ *_2 \circ\,*_1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vec{\vdash}\ \oftype{\vec{s}}{\vec{\sigma}} | *$}
\LeftLabel{(statement block)}
\RightLabel{$\vec{\sigma} = \langle\sigma, \sigma, \ldots, \sigma\rangle$}
\UnaryInfC{$\Gamma \vdash \oftype{\vec{s}}{\sigma} | *$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e}{\text{Bool}} | *_1$}
\AxiomC{$\Gamma^{*_1} \vdash \oftype{s}{\sigma^{*_1}} | *_2$}
\LeftLabel{(while)}
\BinaryInfC{$\Gamma \vdash \oftype{\text{while}(e) s}{\sigma} | *_2 \circ *_1$}
\end{prooftree}

Looking up the type of an identifier $i$ in an environment $\Gamma$ is defined
as follows.

\begin{equation*}
\Gamma(i) = \text{if } (i, \forall \vec{\alpha}.\tau) \in \Gamma \text{ then } \tau[\vec{\alpha} \mapsto
\vec{\beta}], \text{ where } \vec{\beta} \text{ fresh}
\end{equation*}

That is, we generate a fresh type variable for each bound type variable (if any)
in the type of $i$, then we remove the quantifier and replace all
previously bound variables with the fresh ones.

Inferring the types of a vector of expressions is defined by recursion on the
length of the vector as follows. It is assumed that $|\vec{e}| =
|\vec{\alpha}|$.

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma\ \vec{\vdash}\ \oftype{\langle\rangle}{\langle\rangle} | \text{id}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \oftype{e_1}{\alpha_1}|*$}
\AxiomC{$\Gamma^*\ \vec{\vdash}\ \oftype{\langle e_2, \ldots, e_n
\rangle}{(\langle \alpha_2, \ldots, \alpha_n\rangle)^*}|*_1$}
\BinaryInfC{$\Gamma\ \vec{\vdash}\ \oftype{\langle e_1, e_2, \ldots,
e_n\rangle}{\langle \alpha_1, \alpha_2, \ldots, \alpha_n\rangle} | *_1 \circ\,*$}
\end{prooftree}

\section{Further work}

Forbid assignment to functions

\end{document}

% vim: textwidth=80
