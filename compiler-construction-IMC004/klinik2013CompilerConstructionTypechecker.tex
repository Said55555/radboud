\documentclass[a4paper]{article}
%\usepackage{mathptmx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[retainorgcmds]{IEEEtrantools}
%\usepackage[square]{natbib}

% needs debian package texlive-math-extra
\usepackage{stmaryrd} % for \llbracket, \rrbracket (scott brackets)

\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{matrix}

\newcommand{\arr}{\rightarrow}
\newcommand{\todo}[1]{\bigskip \noindent \emph{todo: #1}}
%\newcommand{\todo}[1]{}
\newcommand{\semantics}[1]{\llbracket #1 \rrbracket}

\begin{document}

\title{A Typechecker for SPL, the Simple~Programming~Language}
\author{Markus Klinik (s4220315)}
\maketitle

\section{Implementation Language}

The SPL parser and type checker are written in Haskell, because a
functional language is well-suited for the various programming tasks
that arise when implementing a compiler.

\begin{itemize}

  \item Traversing trees by pattern matching and recursion on algebraic
  data types is most convenient.

  \item Immutable data structures and sharing allow a style of
  programming that resembles mathematical definitions.  This comes in
  handy for example when an environment needs to be passed modified to
  a subcomputation, but the original environment is needed to continue
  later.

  \item Haskell has a rich set of standard and third-party libraries
  which allows focusing on the problem at hand.

\end{itemize}

\section{Preliminaries}

foo bar baz

\end{document}

% vim: textwidth=80
